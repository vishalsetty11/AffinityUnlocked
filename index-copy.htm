<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data?</title>
    <!-- Plotly.js CDN -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f8f0f0 0%, #e0e0e0 100%);
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 900px;
            margin-bottom: 25px;
            box-sizing: border-box;
            /* NEW: Center inline/inline-flex children like the upload section */
            text-align: center; 
        }
        h1 {
            color: #5a2d6b;
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        p {
            text-align: center;
            color: #666;
            font-size: 1.1em;
            margin-bottom: 25px;
        }
        .upload-section {
            border: 2px dashed #9b59b6;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            background-color: #f7f3fb;
            margin-bottom: 30px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            /* NEW: Apply display here, removed inline style */
            display: inline-flex; 
            flex-direction: column; /* Stack children vertically inside upload-section */
            align-items: center; /* Center children inside upload-section */
            /* Removed margin-left: 12rem; */
        }
        .upload-section:hover {
            background-color: #f0eaf5;
        }
        .upload-section input[type="file"] {
            display: none;
        }
        .upload-section .icon {
            font-size: 3em;
            color: #9b59b6;
            margin-bottom: 15px;
        }
        .upload-section h3 {
            color: #7d3c92;
            margin-bottom: 10px;
        }
        .upload-section span {
            color: #a0a0a0;
        }
        /* REFACTORED: analysis-status CSS for better alignment */
        .analysis-status {
            display: flex; /* Use flexbox */
            flex-direction: column; /* Stack children vertically */
            align-items: center; /* Center children horizontally */
            margin-top: 20px;
            /* Removed text-align: center; */
            display: none; /* Controlled by JS */
        }
        .analysis-status .check-icon {
            color: #27ae60;
            font-size: 3em;
            margin-bottom: 10px;
        }
        .analysis-status p { /* For uploadedFileName and errorMessage */
            font-size: 1.2em;
            color: #555;
            margin-bottom: 15px; /* Space below filename */
        }
        /* NEW: Styles for the button wrapper */
        .analysis-buttons-wrapper {
            margin-bottom: 15px; /* Space below buttons */
            display: flex; /* Keep buttons inline-flex */
            gap: 20px; /* Space between buttons */
        }
        .analysis-status button {
            background-color: #e74c3c;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease;
            /* Removed margin as gap handles it */
        }
        .analysis-status button:hover {
            background-color: #c0392b;
        }
        .analysis-status button.start-analysis {
            background-color: #8e44ad;
        }
        .analysis-status button.start-analysis:hover {
            background-color: #6b3283;
        }

        .download-link-container {
            margin-top: 5px; /* Reduced margin to bring closer to buttons */
            margin-bottom: 15px; /* Space below download link */
            display: none; /* Hidden initially */
        }
        .download-link-container a {
            display: inline-block;
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            text-decoration: none;
            font-size: 0.95em;
            transition: background-color 0.3s ease;
        }
        .download-link-container a:hover {
            background-color: #217dbb;
        }

        .analysis-overview, .analysis-section {
            display: none; /* Hidden until analysis starts */
            margin-top: 30px;
        }

        .analysis-section h2 {
            color: #5a2d6b;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .final-verdict {
            text-align: center;
            padding: 30px;
            background-color: #f8f0fb;
            border-radius: 15px;
            margin-top: 40px;
        }
        .final-verdict h2 {
            font-size: 3em;
            color: #8e44ad;
            margin-bottom: 10px;
        }
        .final-verdict .percentage {
            font-size: 4em;
            font-weight: bold;
            color: #e74c3c; /* Red color as in screenshot */
            margin-bottom: 15px;
        }
        .final-verdict h3 {
            font-size: 1.8em;
            color: #4CAF50;
            margin-bottom: 10px;
        }
        .final-verdict p {
            font-style: italic;
            color: #777;
            margin-top: 15px;
            line-height: 1.6;
        }
        /* Refactored metrics display using Grid */
        .metrics-grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Responsive 3-column layout */
            gap: 20px;
            margin-top: 25px;
            justify-content: center; /* Center the grid if items don't fill entire width */
            align-items: start; /* Align items to the top */
        }
        .metric-box {
            background-color: #ffffff;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            text-align: center;
            min-width: 180px; /* Ensure a minimum width */
            box-sizing: border-box; /* Include padding/border in width */
        }
        .metric-box .label {
            font-size: 0.9em;
            color: #777;
            margin-bottom: 5px;
        }
        .metric-box .value {
            font-size: 1.6em;
            font-weight: bold;
            color: #5a2d6b;
        }

        .chart-container {
            width: 100%;
            height: 400px; /* Fixed height for charts */
            margin-top: 20px;
            background-color: #fdfdfd;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
        }
        .error-message {
            color: red;
            text-align: center;
            margin-top: 15px;
        }
        /* New style for the top error message */
        .main-error-message {
            font-size: 1.2em;
            font-weight: bold;
            margin: 10px auto 20px; /* Adjust margin to place it below p tag */
            display: none; /* Hidden by default */
        }
        /* NEW: Styles for the in-page log display */
        .process-log-display {
            background-color: #e8f5e9; /* Light green background */
            border: 1px solid #c8e6c9; /* Green border */
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace; /* Monospace font for logs */
            font-size: 0.9em;
            text-align: left; /* Align text left within the log box */
            max-height: 200px; /* Limit height */
            overflow-y: auto; /* Enable vertical scrolling */
            white-space: pre-wrap; /* Preserve whitespace and wrap text */
            color: #388e3c; /* Dark green text */
            
            /* NEW: Initial hidden state for animation */
            opacity: 0; 
            display: none; /* Hidden by default */
            transition: opacity 0.5s ease-in-out; /* Smooth fade effect */

            width: 90%; /* Match container width */
            max-width: 900px;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Data?</h1>
        <p>Stop guessing and start analyzing. Upload your WhatsApp chat history and let our analysis reveal the true potential of your connection.</p>
        
        <p id="mainErrorMessage" class="error-message main-error-message" style="display: none;"></p>

       <label for="chatFileInput" class="upload-section ai-style-change-1">
            <h3 class="ai-style-change-3">Upload your chat file</h3>
            <div class="icon ai-style-change-2">‚¨ÜÔ∏è</div>
            <span style="font-size: 0.9em;">Drag & drop your file here or <span style="color: #9b59b6; text-decoration: underline;">click to browse</span></span>
            <input type="file" id="chatFileInput" accept=".txt">
        </label>
        

        <div id="analysisStatus" class="analysis-status">
            <p id="uploadedFileName">No file selected.</p>
            <div class="analysis-buttons-wrapper">
                <button onclick="clearFile()">Clear</button>
                <button class="start-analysis" onclick="startAnalysis(event)">Start Analysis</button>
            </div>
            <!-- REMOVED: Download Link Container -->
            <p id="errorMessage" class="error-message" style="display: none;"></p>
        </div>

        <div id="processLogDisplay" class="process-log-display"></div>
    </div>

    <div id="analysisOverview" class="container analysis-overview">
        <div class="final-verdict">
            <h2>Final Verdict</h2>
            <div class="percentage" id="finalVerdictPercentage">0%</div>
            <h3 id="verdictText"></h3>
            <p>You're both showing genuine interest with your communication patterns. The vibes are definitely positive.</p>
            <p style="font-size: 0.9em;">"Love is not just about the numbers, but the numbers don't lie either! ü•∞üìà"</p>
        </div>
        <div class="metrics-grid-container">
            <div class="metric-box">
                <div class="label">Total Messages</div>
                <div class="value" id="totalMessages">0</div>
            </div>
            <div class="metric-box">
                <div class="label">Avg Reply Time</div>
                <div class="value" id="avgReplyTime">0 hrs</div>
            </div>
            <div class="metric-box">
                <div class="label">Media Count</div>
                <div class="value" id="mediaCount">0</div>
            </div>
        </div>
    </div>

    <div id="replyTimeAnalysis" class="container analysis-section">
        <h2>Reply Time Analysis</h2>
        <p>Track how quickly they respond to your messages</p>
        <div class="chart-container" id="replyTimeChart"></div>
        <div class="metrics-grid-container">
            <div class="metric-box">
                <div class="label">Fastest Reply</div>
                <div class="value" id="fastestReply">0 hrs</div>
            </div>
            <div class="metric-box">
                <div class="label">Slowest Reply</div>
                <div class="value" id="slowestReply">0 hrs</div>
            </div>
            <div class="metric-box">
                <div class="label">Average</div>
                <div class="value" id="averageReplyTimeChart">0 hrs</div>
            </div>
        </div>
    </div>

    <div id="emojiAnalysis" class="container analysis-section">
        <h2>Emoji Analysis</h2>
        <p>What do their emoji choices reveal? Hearts and fire emojis are good signs! üî•‚ù§Ô∏è</p>
        <div class="chart-container" id="emojiChart"></div>
    </div>

    <div id="conversationFrequencyAnalysis" class="container analysis-section" style="display: none;">
        <h2>Conversation Frequency</h2>
        <p>See how often messages are exchanged over time.</p>
        <div class="chart-container" id="conversationFrequencyChart"></div>
    </div>

    <script>
        let analysisData = {}; 
        let uploadedFile = null; 
        let fileContentText = ''; 
        let processLogDisplayElement; 

        // Constants for time unit conversions
        const MINUTES_IN_HOUR = 60;
        const MINUTES_IN_DAY = 24 * MINUTES_IN_HOUR;
        const MINUTES_IN_MONTH = 30 * MINUTES_IN_DAY; // Approximation for a month
        const MINUTES_IN_YEAR = 365 * MINUTES_IN_DAY; // Approximation for a year

        // Helper function to log messages to the UI display
        function logToDisplay(message, isError = false) {
            if (!processLogDisplayElement) {
                processLogDisplayElement = document.getElementById('processLogDisplay');
            }
            if (processLogDisplayElement) {
                const timestamp = new Date().toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const logLine = document.createElement('div');
                logLine.textContent = `[${timestamp}] ${message}`;
                if (isError) {
                    logLine.style.color = 'red';
                    logLine.style.fontWeight = 'bold';
                }
                processLogDisplayElement.appendChild(logLine);
                processLogDisplayElement.scrollTop = processLogDisplayElement.scrollHeight;
            }
        }

        // Helper function: Formats minutes into appropriate units (min, hrs, days, months, years)
        // With specific decimal precisions and "less than 2" rule.
        function formatTimeUnits(totalMinutes) {
            if (totalMinutes === 0) return '0 sec'; 
            if (totalMinutes < 0) return 'N/A'; 

            const SECONDS_IN_MINUTE = 60;

            if (totalMinutes < 1) { 
                const seconds = totalMinutes * SECONDS_IN_MINUTE;
                return `${seconds.toFixed(2)} sec`; 
            } else if (totalMinutes < MINUTES_IN_HOUR) {
                return `${totalMinutes.toFixed(1)} min`; 
            } else if (totalMinutes < MINUTES_IN_DAY) {
                const hours = totalMinutes / MINUTES_IN_HOUR;
                const decimalPlaces = (hours < 2) ? 1 : 0; 
                return `${hours.toFixed(decimalPlaces)} ${hours === 1.0 ? 'hr' : 'hrs'}`;
            } else if (totalMinutes < MINUTES_IN_MONTH) { 
                const days = totalMinutes / MINUTES_IN_DAY;
                const decimalPlaces = (days < 2) ? 1 : 0; 
                return `${days.toFixed(decimalPlaces)} ${days === 1.0 ? 'day' : 'days'}`;
            } else if (totalMinutes < MINUTES_IN_YEAR) { 
                const months = totalMinutes / MINUTES_IN_MONTH;
                const decimalPlaces = (months < 2) ? 1 : 0; 
                return `${months.toFixed(decimalPlaces)} ${months === 1.0 ? 'month' : 'months'}`;
            } else {
                const years = totalMinutes / MINUTES_IN_YEAR;
                const decimalPlaces = (years < 2) ? 1 : 0; 
                return `${years.toFixed(decimalPlaces)} ${years === 1.0 ? 'year' : 'years'}`;
            }
        }


        // Helper functions for Love Score calculation
        function calculateRScore(T) { 
            const T_hours = T / 60;
            if (T_hours < 2) return 25;
            if (T_hours < 5) return 15;
            if (T_hours < 10) return 10;
            if (T_hours < 20) return 5;
            if (T_hours > 30) return -15;
            return 0;
        }

        function calculateEScore(e) { 
            if (e > 0.5) return 20;
            if (e > 0.2) return 15;
            if (e > 0.1) return 10;
            if (e > 0.05) return 5;
            return 0;
        }

        function calculateMScore(m) { 
            if (m > 0.45) return 15;
            if (m > 0.35) return 10;
            if (m > 0.25) return 5;
            if (m < 0.25) return -10;
            return 0;
        }

        function calculateCScore(d) { 
            if (d > 0.8) return 15;
            if (d > 0.5) return 10;
            if (d > 0.3) return 5;
            return 0;
        }

        function getBaseScore(data) {
            if (data.totalMessages === 0) {
                logToDisplay("Base Score Logic: 0 (No messages found in chat file)");
                return 0;
            }

            if (data.parsedSenders.length < 2) {
                logToDisplay("Base Score Logic: 0 (Only one sender detected in chat)");
                return 0;
            }

            if (data.messageBalance < 0.05) { 
                logToDisplay("Base Score Logic: 0 (Chat is extremely imbalanced, effectively one-sided)");
                return 0;
            }

            if (data.lastMessageTimestamp) {
                const currentTime = new Date();
                const oneMonthInMs = 30 * 24 * 60 * 60 * 1000; 
                const timeDifferenceMs = currentTime.getTime() - data.lastMessageTimestamp.getTime();

                logToDisplay(`Base Score Logic - Last Message Time: ${data.lastMessageTimestamp.toLocaleString('en-IN')}`);
                logToDisplay(`Base Score Logic - Current System Time: ${currentTime.toLocaleString('en-IN')}`);
                logToDisplay(`Base Score Logic - Time Difference: ${ (timeDifferenceMs / (1000 * 60 * 60 * 24)).toFixed(1)} days`);
                logToDisplay(`Base Score Logic - One Month Threshold: ${oneMonthInMs / (1000 * 60 * 60 * 24)} days`);
                logToDisplay(`Base Score Logic - Is Ghosted (diff > threshold)? ${timeDifferenceMs > oneMonthInMs}`);


                if (timeDifferenceMs > oneMonthInMs) {
                    logToDisplay("Base Score Logic: 0 (Chat is older than 1 month / Ghosted)");
                    return 0;
                }
            }

            logToDisplay("Base Score Logic: 50 (Active and balanced communication detected)");
            return 50;
        }


        function calculateOverallLoveScore(data) {
            const baseScore = getBaseScore(data); 

            const rScore = calculateRScore(data.avgReplyTimeMinutes || 0);
            const eScore = calculateEScore(data.emojiUsageRatio || 0);
            const mScore = calculateMScore(data.messageBalance || 0);
            const cScore = calculateCScore(data.consistency || 0);

            return baseScore + rScore + eScore + mScore + cScore;
        }

        // --- Chat Parser Function
        function parseChatContent(text) {
            const lines = text.split('\n');
            const chatLineRegex = /^(\d{1,2}\/\d{1,2}\/\d{2,4}), (\d{1,2}:\d{2}) - ([^:]+?): (.*)$/;
            
            const emojiRegex = /(\p{Emoji_Presentation}|\p{Emoji}\uFE0F|\u200d|\uFE0F)/gu;

            const mediaIndicators = [
                '<Media omitted>', '(file attached)', 'sticker omitted',
                'video omitted', 'audio omitted', 'image omitted',
                'GIF omitted', 'document omitted', '<this message was edited>' 
            ];
            const systemMessageKeywords = [
                'Messages and calls are end-to-end encrypted',
                'You created group', 'You changed the group icon',
                'You left', 'added', 'removed', 'changed the subject to',
                'You changed your phone number', 'Missed voice call', 'Missed video call'
            ];


            let parsedMessages = []; 
            let currentMessage = null; 
            
            for (const line of lines) {
                const match = line.match(chatLineRegex);

                if (match) {
                    if (currentMessage) {
                        parsedMessages.push(currentMessage);
                    }

                    const [, dateStr, timeStr, senderRaw, content] = match;
                    const sender = senderRaw.trim(); 
                    
                    const [month, day, year] = dateStr.split('/').map(Number);
                    const fullYear = (year < 70) ? (2000 + year) : (1900 + year); 
                    const [hours, minutes] = timeStr.split(':').map(Number);
                    const timestamp = new Date(fullYear, month - 1, day, hours, minutes);
                    
                    if (isNaN(timestamp.getTime())) {
                        console.warn("Skipping message start due to invalid date/time format:", line);
                        currentMessage = null; 
                        continue; 
                    }

                    currentMessage = {
                        sender: sender,
                        timestamp: timestamp,
                        content: content.trim() 
                    };

                } else if (currentMessage) {
                    currentMessage.content += "\n" + line.trim();
                }
            }

            if (currentMessage) {
                parsedMessages.push(currentMessage);
            }

            let totalMessages = 0;
            let mediaCount = 0;
            let senderCounts = {};
            let emojiCounts = {};
            let replyTimesMs = [];
            let senderOrder = []; 
            let activeDays = new Set(); 
            let lastMessageTimestamp = null; 

            parsedMessages.forEach(msg => {
                const isSystem = systemMessageKeywords.some(keyword => msg.content.includes(keyword));
                if (isSystem) {
                    return; 
                }

                totalMessages++; 
                lastMessageTimestamp = msg.timestamp; 

                const isMedia = mediaIndicators.some(indicator => msg.content.toLowerCase().includes(indicator.toLowerCase())); 
                if (isMedia) {
                    mediaCount++;
                }
                
                senderCounts[msg.sender] = (senderCounts[msg.sender] || 0) + 1;

                const emojisInMessage = msg.content.match(emojiRegex);
                if (emojisInMessage) {
                    emojisInMessage.forEach(emoji => {
                        if (emoji.length > 0 && !/[\u200d\uFE0F]/.test(emoji)) { 
                            emojiCounts[emoji] = (emojiCounts[emoji] || 0) + 1;
                        }
                    });
                }
                
                activeDays.add(msg.timestamp.toLocaleDateString('en-US')); 

                senderOrder.push({ sender: msg.sender, timestamp: msg.timestamp });
            });


            const sortedSenders = Object.entries(senderCounts).sort(([, countA], [, countB]) => countB - countA);
            const personA = sortedSenders[0] ? sortedSenders[0][0] : null;
            const personB = sortedSenders[1] ? sortedSenders[1][0] : null;

            if (personA && personB) {
                let lastMsgTimeA = null;
                let lastMsgTimeB = null;

                for (let i = 0; i < senderOrder.length; i++) {
                    const current = senderOrder[i];
                    if (current.sender === personA) {
                        if (lastMsgTimeB && current.timestamp.getTime() > lastMsgTimeB.getTime()) { 
                            const replyDuration = current.timestamp.getTime() - lastMsgTimeB.getTime();
                            if (replyDuration > 0) replyTimesMs.push(replyDuration);
                        }
                        lastMsgTimeA = current.timestamp;
                    } else if (current.sender === personB) {
                        if (lastMsgTimeA && current.timestamp.getTime() > lastMsgTimeA.getTime()) { 
                            const replyDuration = current.timestamp.getTime() - lastMsgTimeA.getTime();
                            if (replyDuration > 0) replyTimesMs.push(replyDuration);
                        }
                        lastMsgTimeB = current.timestamp;
                    }
                }
            }


            const totalE = Object.values(emojiCounts).reduce((sum, count) => sum + count, 0);
            const emojiUsageRatio = totalMessages > 0 ? totalE / totalMessages : 0;

            let messageBalance = 0;
            const personAMessages = senderCounts[personA] || 0;
            const personBMessages = senderCounts[personB] || 0;
            if ((personAMessages + personBMessages) > 0) {
                 messageBalance = Math.min(personAMessages, personBMessages) / Math.max(personAMessages, personBMessages);
            }
            
            let avgReplyTimeMinutes = 0;
            let fastestReplyMinutes = 0;
            let slowestReplyMinutes = 0;

            if (replyTimesMs.length > 0) {
                const totalReplyTimeMs = replyTimesMs.reduce((sum, time) => sum + time, 0);
                avgReplyTimeMinutes = (totalReplyTimeMs / replyTimesMs.length) / (1000 * 60);
                fastestReplyMinutes = Math.min(...replyTimesMs) / (1000 * 60);
                slowestReplyMinutes = Math.max(...replyTimesMs) / (1000 * 60);
            }
            
            let firstDate = null;
            let lastDate = null;
            if (activeDays.size > 0) {
                const sortedDates = Array.from(activeDays).sort((a, b) => new Date(a) - new Date(b));
                firstDate = new Date(sortedDates[0]);
                lastDate = new Date(sortedDates[sortedDates.length - 1]);
            }
            
            let totalChatDays = 0;
            if (firstDate && lastDate) {
                totalChatDays = Math.ceil(Math.abs(lastDate - firstDate) / (1000 * 60 * 60 * 24)) + 1; 
            }
            const consistency = totalChatDays > 0 ? activeDays.size / totalChatDays : 0;

            const replyTimeDistribution = [];
            const maxMinutes = slowestReplyMinutes > 0 ? slowestReplyMinutes : (avgReplyTimeMinutes * 2 || 60000); 
            const binSize = maxMinutes / 10;
            const bins = Array(11).fill(0);

            replyTimesMs.forEach(ms => {
                const minutes = ms / (1000 * 60);
                const binIndex = Math.min(Math.floor(minutes / binSize), bins.length - 1);
                bins[binIndex]++;
            });

            for (let i = 0; i < bins.length; i++) {
                replyTimeDistribution.push({ x: i * binSize, y: bins[i] });
            }

            return {
                fileName: "Uploaded_Chat.txt",
                fileSize: (text.length / 1024).toFixed(1) + " KB",
                totalMessages,
                avgReplyTimeMinutes: parseFloat(avgReplyTimeMinutes.toFixed(1)),
                fastestReplyMinutes: parseFloat(fastestReplyMinutes.toFixed(1)),
                slowestReplyMinutes: parseFloat(slowestReplyMinutes.toFixed(1)),
                mediaCount,
                emojiUsageData: Object.entries(emojiCounts).map(([emoji, count]) => ({ emoji, count })).sort((a,b) => b.count - a.count), // Sorted by count descending
                emojiUsageRatio: parseFloat(emojiUsageRatio.toFixed(2)),
                messageBalance: parseFloat(messageBalance.toFixed(2)),
                consistency: parseFloat(consistency.toFixed(2)),
                replyTimeDistribution: replyTimeDistribution,
                parsedSenders: sortedSenders.map(s => s[0]),
                replyTimesMs: replyTimesMs,
                lastMessageTimestamp: lastMessageTimestamp,
                parsedMessages: parsedMessages // IMPORTANT: Return parsedMessages for Conversation Frequency Chart
            };
        }

        // --- UI and Graphing Functions ---

        document.getElementById('chatFileInput').addEventListener('change', function(event) {
            uploadedFile = event.target.files[0];
            if (uploadedFile) {
                document.getElementById('uploadedFileName').innerText = `${uploadedFile.name} (${(uploadedFile.size / 1024).toFixed(1)} KB)`;
                document.getElementById('analysisStatus').style.display = 'block';
                document.getElementById('errorMessage').style.display = 'none'; 
                document.getElementById('mainErrorMessage').style.display = 'none'; 

            } else {
                document.getElementById('uploadedFileName').innerText = `No file selected.`;
                document.getElementById('analysisStatus').style.display = 'none';
                document.getElementById('mainErrorMessage').style.display = 'none'; 
            }
        });

        function clearFile() {
            uploadedFile = null;
            document.getElementById('chatFileInput').value = '';
            document.getElementById('uploadedFileName').innerText = 'No file selected.';
            document.getElementById('analysisStatus').style.display = 'none';
            document.getElementById('analysisOverview').style.display = 'none';
            document.getElementById('replyTimeAnalysis').style.display = 'none';
            document.getElementById('emojiAnalysis').style.display = 'none';
            document.getElementById('conversationFrequencyAnalysis').style.display = 'none'; 
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('mainErrorMessage').style.display = 'none'; 
            
            document.getElementById('totalMessages').innerText = '0';
            document.getElementById('avgReplyTime').innerText = '0 hrs'; 
            document.getElementById('mediaCount').innerText = '0';
            document.getElementById('fastestReply').innerText = '0 hrs'; 
            document.getElementById('slowestReply').innerText = '0 hrs'; 
            document.getElementById('averageReplyTimeChart').innerText = '0 hrs'; 
            document.getElementById('finalVerdictPercentage').innerText = '0%';
            document.getElementById('verdictText').innerText = '';

            if (processLogDisplayElement) {
                processLogDisplayElement.style.opacity = '0'; 
                setTimeout(() => { 
                    processLogDisplayElement.style.display = 'none';
                    processLogDisplayElement.innerHTML = ''; 
                }, 500); 
            }
        }

        function showProcessLog() {
            if (!processLogDisplayElement) {
                processLogDisplayElement = document.getElementById('processLogDisplay');
            }
            processLogDisplayElement.innerHTML = ''; 
            processLogDisplayElement.style.display = 'block';
            processLogDisplayElement.offsetWidth; 
            processLogDisplayElement.style.opacity = '1';
        }

        function hideProcessLog() {
            if (!processLogDisplayElement) {
                processLogDisplayElement = document.getElementById('processLogDisplay');
            }
            processLogDisplayElement.style.opacity = '0'; 
            setTimeout(() => { 
                processLogDisplayElement.style.display = 'none';
                processLogDisplayElement.innerHTML = ''; 
            }, 500); 
        }

        function startAnalysis(event) {
            event.preventDefault(); 

            console.log("Starting analysis..."); 
            const errorMessageElement = document.getElementById('errorMessage');
            const mainErrorMessageElement = document.getElementById('mainErrorMessage'); 

            errorMessageElement.style.display = 'none';
            mainErrorMessageElement.style.display = 'none';

            showProcessLog();
            logToDisplay("Starting analysis..."); 

            if (!uploadedFile) {
                mainErrorMessageElement.innerText = "Analysis aborted: Please upload a chat .txt file first."; 
                logToDisplay("Analysis aborted: No file uploaded.", true); 
                mainErrorMessageElement.style.display = 'block';
                console.error("Analysis aborted: No file uploaded."); 
                hideProcessLog(); 
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                logToDisplay("File loaded. Attempting to parse content..."); 
                try {
                    analysisData = parseChatContent(e.target.result);
                    logToDisplay(`Parsing complete. Total messages found: ${analysisData.totalMessages}`); 


                    if (analysisData.totalMessages === 0) {
                        mainErrorMessageElement.innerText = "Analysis failed: No messages found in the chat file. Please ensure the file is a standard WhatsApp .txt export and the format matches (M/D/YY, HH:MM - Sender: Message). If the issue persists, try exporting your chat again or check for unusual line formats.";
                        logToDisplay("Analysis failed: No messages found after parsing. Check file format.", true); 
                        mainErrorMessageElement.style.display = 'block';
                        console.error("Analysis failed: No messages found after parsing. Check file format."); 
                        document.getElementById('analysisOverview').style.display = 'none';
                        document.getElementById('replyTimeAnalysis').style.display = 'none';
                        document.getElementById('emojiAnalysis').style.display = 'none';
                        document.getElementById('conversationFrequencyAnalysis').style.display = 'none'; 
                        hideProcessLog(); 
                        return;
                    }
                    if (analysisData.parsedSenders.length < 2 && analysisData.totalMessages > 0) {
                        mainErrorMessageElement.innerText = `Analysis Warning: Only one active sender (${analysisData.parsedSenders[0] || 'Unknown'}) found. Love score analysis is designed for two-person chats, so some metrics might be limited.`;
                        logToDisplay("Warning: Only one sender detected. Love score metrics might be limited.", true); 
                        mainErrorMessageElement.style.display = 'block';
                        console.warn("Warning: Only one sender detected. Love score metrics might be limited."); 
                    }


                    document.getElementById('analysisOverview').style.display = 'block';
                    document.getElementById('replyTimeAnalysis').style.display = 'block';
                    document.getElementById('emojiAnalysis').style.display = 'block';
                    document.getElementById('conversationFrequencyAnalysis').style.display = 'block'; // Show new chart

                    updateMetricsSummary();
                    plotReplyTimeChart();
                    plotEmojiChart();
                    plotConversationFrequencyChart(); // Call new chart function
                    updateFinalVerdict();
                    logToDisplay("Analysis and plotting complete."); 
                    hideProcessLog(); 
                } catch (error) {
                    console.error("FATAL Error during analysis or plotting:", error); 
                    mainErrorMessageElement.innerText = `An unexpected error occurred during chat analysis: ${error.message}. This often indicates a problem with the file format or an internal issue. Please check your browser's console (F12 > Console) for technical details and try a different file if needed.`;
                    logToDisplay(`FATAL Error: ${error.message}`, true); 
                    mainErrorMessageElement.style.display = 'block';
                    document.getElementById('analysisOverview').style.display = 'none';
                    document.getElementById('replyTimeAnalysis').style.display = 'none';
                    document.getElementById('emojiAnalysis').style.display = 'none';
                    document.getElementById('conversationFrequencyAnalysis').style.display = 'none'; 
                    hideProcessLog(); 
                }
            };
            reader.onerror = function(event) {
                mainErrorMessageElement.innerText = "Error: Failed to read the uploaded file. Please ensure it's a valid text file.";
                logToDisplay("Error: Failed to read the uploaded file.", true); 
                mainErrorMessageElement.style.display = 'block';
                console.error("FileReader error:", event); 
                document.getElementById('analysisOverview').style.display = 'none';
                document.getElementById('replyTimeAnalysis').style.display = 'none';
                document.getElementById('emojiAnalysis').style.display = 'none';
                document.getElementById('conversationFrequencyAnalysis').style.display = 'none'; 
                hideProcessLog(); 
            };
            reader.readAsText(uploadedFile);
        }

        function updateMetricsSummary() {
            document.getElementById('totalMessages').innerText = analysisData.totalMessages;
            
            // Convert and display Avg Reply Time
            document.getElementById('avgReplyTime').innerText = formatTimeUnits(analysisData.avgReplyTimeMinutes);

            document.getElementById('mediaCount').innerText = analysisData.mediaCount;

            // Convert and display Fastest Reply Time
            document.getElementById('fastestReply').innerText = formatTimeUnits(analysisData.fastestReplyMinutes);
            
            // Convert and display Slowest Reply Time
            document.getElementById('slowestReply').innerText = formatTimeUnits(analysisData.slowestReplyMinutes);
            
            // Convert and display Average for chart display
            document.getElementById('averageReplyTimeChart').innerText = formatTimeUnits(analysisData.avgReplyTimeMinutes);
        }

        function updateFinalVerdict() {
            const calculatedLoveScore = calculateOverallLoveScore(analysisData);
            let percentage = Math.min(100, Math.max(0, calculatedLoveScore)); 

            let verdictText = "Good potential!";
            if (percentage >= 80) verdictText = "Strong romantic potential! ‚ù§Ô∏è";
            else if (percentage >= 60) verdictText = "Positive vibes! üòä";
            else if (percentage >= 40) verdictText = "Okay, needs work. ü§î";
            else verdictText = "Hmm, maybe just friends. üò¨";


            document.getElementById('finalVerdictPercentage').innerText = `${percentage}%`;
            document.getElementById('verdictText').innerText = verdictText;
            
            if(percentage < 50) document.getElementById('finalVerdictPercentage').style.color = '#e74c3c'; 
            else if (percentage < 75) document.getElementById('finalVerdictPercentage').style.color = '#f39c12';
            else document.getElementById('finalVerdictPercentage').style.color = '#27ae60';
        }

        function plotReplyTimeChart() {
            if (!analysisData.replyTimeDistribution || analysisData.replyTimeDistribution.length === 0 || analysisData.replyTimesMs?.length === 0) {
                Plotly.purge('replyTimeChart');
                document.getElementById('replyTimeChart').innerText = 'No reply time data available for plotting. (Perhaps only one sender or very few replies between distinct senders)';
                console.warn("No reply time data to plot.");
                logToDisplay("Warning: No reply time data to plot.", true); 
                return;
            }

            const maxPlotMinutes = analysisData.replyTimeDistribution.reduce((max, d) => Math.max(max, d.x), 0); 

            // Generate custom tick values and texts for better readability on X-axis
            const potentialTickMinutes = [
                0, 1, 5, 15, 30, // Minutes
                MINUTES_IN_HOUR, 2 * MINUTES_IN_HOUR, 6 * MINUTES_IN_HOUR, 12 * MINUTES_IN_HOUR, // Hours
                MINUTES_IN_DAY, 2 * MINUTES_IN_DAY, 5 * MINUTES_IN_DAY, 10 * MINUTES_IN_DAY, 20 * MINUTES_IN_DAY, // Days
                MINUTES_IN_MONTH, 2 * MINUTES_IN_MONTH, 6 * MINUTES_IN_MONTH, // Months
                MINUTES_IN_YEAR // Years
            ].filter(t => t <= maxPlotMinutes * 1.1 + 10); 

            const customTickVals = [];
            const customTickText = [];

            if (maxPlotMinutes > 0 && !potentialTickMinutes.includes(0)) {
                customTickVals.push(0);
                customTickText.push('0 min');
            }

            potentialTickMinutes.forEach(minutes => {
                if (!customTickVals.includes(minutes)) { 
                    customTickVals.push(minutes);
                    customTickText.push(formatTimeUnits(minutes)); 
                }
            });

            customTickVals.sort((a,b) => a-b); 
            const finalTickText = customTickVals.map(val => formatTimeUnits(val)); 


            const trace = {
                x: analysisData.replyTimeDistribution.map(d => d.x), 
                y: analysisData.replyTimeDistribution.map(d => d.y),
                mode: 'lines+markers', 
                line: { color: '#e74c3c', width: 3 },
                marker: { color: '#8e44ad', size: 8 },
                hoverinfo: 'x+y', 
                name: 'Frequency' 
            };

            const layout = {
                title: {
                    text: 'Reply Time Distribution',
                    font: { color: '#555' }
                },
                xaxis: {
                    title: `Reply Time`, 
                    tickvals: customTickVals,
                    ticktext: finalTickText,
                    tickangle: -45, 
                    tickfont: { color: '#666' },
                    linecolor: '#ccc',
                    gridcolor: '#eee',
                    zeroline: false
                },
                yaxis: {
                    title: 'Frequency/Density', 
                    tickfont: { color: '#666' },
                    linecolor: '#ccc',
                    gridcolor: '#eee',
                    rangemode: 'tozero'
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                margin: { l: 60, r: 20, b: 60, t: 40 },
                showlegend: false 
            };

            Plotly.newPlot('replyTimeChart', [trace], layout);
            logToDisplay("Reply Time Chart plotted."); 
        }

        function plotEmojiChart() {
            if (!analysisData.emojiUsageData || analysisData.emojiUsageData.length === 0) {
                Plotly.purge('emojiChart');
                document.getElementById('emojiChart').innerText = 'No emoji data available for plotting.';
                console.warn("No emoji data to plot.");
                logToDisplay("Warning: No emoji data to plot.", true); 
                return;
            }

            const sortedEmojiData = [...analysisData.emojiUsageData].sort((a,b) => b.count - a.count); 

            const emojiX = sortedEmojiData.map(d => d.count);
            const emojiY = sortedEmojiData.map(d => d.emoji);

            const trace = {
                x: emojiX,
                y: emojiY,
                type: 'bar', 
                orientation: 'h', 
                marker: { color: '#9b59b6' }, 
                hoverinfo: 'x+y',
                name: 'Emoji Count'
            };

            const layout = {
                title: {
                    text: 'Emoji Usage Count',
                    font: { color: '#555' }
                },
                xaxis: {
                    title: 'Count', 
                    tickfont: { color: '#666' },
                    linecolor: '#ccc',
                    gridcolor: '#eee',
                    range: [0, Math.max(...emojiX) + 0.5],
                    rangemode: 'tozero'
                },
                yaxis: {
                    title: 'Emoji', 
                    tickfont: { color: '#666' },
                    linecolor: '#ccc',
                    gridcolor: '#eee',
                    automargin: true
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                margin: { l: 60, r: 20, b: 60, t: 40 },
                showlegend: false
            };

            Plotly.newPlot('emojiChart', [trace], layout);
            logToDisplay("Emoji Chart plotted."); 
        }

        // NEW: Function to plot Conversation Frequency Chart
        function plotConversationFrequencyChart() {
            // Ensure parsedMessages is available and not empty
            if (!analysisData.parsedMessages || analysisData.parsedMessages.length === 0) {
                Plotly.purge('conversationFrequencyChart');
                document.getElementById('conversationFrequencyChart').innerText = 'No conversation frequency data available.';
                logToDisplay("Warning: No conversation frequency data to plot.", true);
                return;
            }

            // Get the timestamp of the first message
            const firstMsgDate = analysisData.parsedMessages[0].timestamp;
            const today = new Date(); 

            const dailyMessageCounts = new Map();

            // Initialize map with all dates from first message to today, with count 0
            // Ensure dates are normalized to start of day for consistent keys
            let currentDate = new Date(firstMsgDate);
            currentDate.setHours(0, 0, 0, 0); 

            const endDate = new Date(today);
            endDate.setHours(0, 0, 0, 0); 

            while (currentDate <= endDate) {
                dailyMessageCounts.set(currentDate.toISOString().slice(0, 10), 0); // YYYY-MM-DD string as key
                currentDate.setDate(currentDate.getDate() + 1); // Move to the next day
            }

            // Populate daily message counts from parsed messages
            analysisData.parsedMessages.forEach(msg => {
                const msgDate = new Date(msg.timestamp);
                msgDate.setHours(0, 0, 0, 0); // Normalize message timestamp to start of day
                const dateString = msgDate.toISOString().slice(0, 10);
                if (dailyMessageCounts.has(dateString)) { // Only count if date is within our initialized range
                    dailyMessageCounts.set(dateString, dailyMessageCounts.get(dateString) + 1);
                }
            });

            // Prepare data for Plotly
            const plotX = Array.from(dailyMessageCounts.keys()).sort(); // Get sorted dates (YYYY-MM-DD strings)
            const plotY = plotX.map(date => dailyMessageCounts.get(date)); // Get counts for each date

            const trace = {
                x: plotX,
                y: plotY,
                type: 'bar', // Bar chart for frequency
                marker: { color: '#27ae60' }, // Green color
                name: 'Message Count'
            };

            const layout = {
                title: {
                    text: 'Daily Conversation Frequency',
                    font: { color: '#555' }
                },
                xaxis: {
                    title: 'Date',
                    tickfont: { color: '#666' },
                    linecolor: '#ccc',
                    gridcolor: '#eee',
                    type: 'date', // Plotly will handle date formatting for dates
                    range: [firstMsgDate.toISOString().slice(0, 10), today.toISOString().slice(0, 10)] // Ensure range from first message to today
                },
                yaxis: {
                    title: 'Number of Messages',
                    tickfont: { color: '#666' },
                    linecolor: '#ccc',
                    gridcolor: '#eee',
                    rangemode: 'tozero'
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                margin: { l: 60, r: 20, b: 60, t: 40 },
                showlegend: false
            };

            Plotly.newPlot('conversationFrequencyChart', [trace], layout);
            logToDisplay("Conversation Frequency Chart plotted.");
        }


        // Initialize display on load
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('analysisStatus').style.display = 'none';
            document.getElementById('analysisOverview').style.display = 'none';
            document.getElementById('replyTimeAnalysis').style.display = 'none';
            document.getElementById('emojiAnalysis').style.display = 'none';
            document.getElementById('conversationFrequencyAnalysis').style.display = 'none'; 
            document.getElementById('downloadLinkContainer').style.display = 'none'; 
            document.getElementById('mainErrorMessage').style.display = 'none'; 
            document.getElementById('processLogDisplay').style.display = 'none'; 
        });
    </script>
</body>
</html>